# Week 5A - Canvas Review

## I. Practice Quiz
- [Week 5A - Practice Quiz](../notes/5A-canvas-quiz.md)
  - this covers more of the canvas concepts you are expected to know for Exam #1

---

## II. Exam #1
- When: Next Thursday - Week 6B
  - see [Exam #1 Details](../notes/exam-1-details.md)
- Graded Quiz next time! Counts as one exercise
- Also - let's review the dropboxes to see what the upcoming assignments are (and see Announcement in myCourses)
  
---

## III. Previous Assignments

- Review: [PE-05 - Canvas Screensaver](../pe/pe-05.md)
  - helper functions written for you - `getRandomColor()` and `getRandomInt(min, max)` 
  - writing your own helper functions:
    - `drawRectangle(ctx,x,y,width,height,fillStyle="black",lineWidth=0,strokeStyle="black")`
    - `drawArc(ctx,x,y,radius,fillStyle="black",lineWidth=0,strokeStyle="black", startAngle=0,endAngle=Math.PI * 2)`
    - `drawLine(ctx,x1,y1,x2,y2,lineWidth=1,strokeStyle="black")`
  - our helper functions utilized the  ["drawing state stack"](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/save#the_drawing_state) and [`ctx.save()`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/save) / [`ctx.restore()`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)
  - getting coordinates of mouse clicks with `canvasClicked()`
  - rectangles the hard way - `ctx.beginPath()`, [`ctx.rect()`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect), `ctx.closePath()`
  - [`window.requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
- Demo:
  - fix the "spam the Play button" issue
  - add *named parameters* for a helper function (see "Refactor the Canvas Screensaver - optional challenge" below)
    
---

## IV. Upcoming Assignments
- [Assignment - Refactor the Canvas Screensaver](../checkoffs/refactor-screensaver.md)
- [PE-06 - Animated Sine Wave / Algorithmic Botany (Phyllotaxis)](../pe/pe-06.md)

---

## V. A little more canvas
- [Canvas 2D Essential Skills #6 - Review & More About Paths](https://github.com/tonethar/IGME-330-Master/blob/master/notes/6-review-and-more-about-paths.md)

---

## VI. What about Breakout, from last time?

- Below is the complete version of "Breakout 2" - what's new?
- Bricks:
  - a 1D array to hold our brick "sprites"
  - implemented as object literals
  - created via [`Object.assign()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  - AABB collision detection
  - when collisions happen, the brick `'alive` property is set to `false`
    - it won't be drawn on the next frame
    - collisions will not be checked
    - better than removing from the `bricks` array - remember *object pooling*? (from Circle Blast in IGME-235)
- Text:
  - score drawn with `ctx.fillText(text, x, y)`
- Audio:
  - synthesized sound played with the [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API) (we'll discuss this week 7)
  - note that Web Audio won't function until the user has interacted with the window in some way - by clicking, usually
  - the `const playSfx = (freq, type, dur) => {...}` function does most of the work
  - note the technique of named functions that call `playSfx()` with values - makes for more legible code!

```js
const sndBallBrick = () => playSfx(500, 'square', 0.1);  
const sndBallPaddle = () => playSfx(300, 'triangle', 0.1);
const sndBallWall = () => playSfx(200, 'sine', 0.1);
```

- Finally, let's see if we can factor some of this code "out" into other files:
  - the audio code
  - the game constants

**breakout-2.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Breakout 2</title>
	<style>
  body{
    background-color: #222;
  }
	canvas{
		border:2px solid #fff;;
	}
	</style>
	<script type="module">
		const canvas = document.querySelector("canvas");
		const ctx = canvas.getContext("2d");

    // Game Constants
    const BG_COLOR = "black";
    const PADDLE_COLOR = "limegreen";
    const PADDLE_WIDTH = 100;
    const PADDLE_HEIGHT = 10;
    const BALL_COLOR = "#FF0077";
    const BALL_SPEED = 10;

    // part II
    const BRICK_ROWS = 5;
    const BRICK_COLS = 8;
    const BRICK_PADDING = 10;
    const BRICK_OFFSET_TOP = 30;
    const BRICK_OFFSET_LEFT = 35;
    const BRICK_WIDTH = 62;
    const BRICK_HEIGHT = 20;

    const paddle = { x: 250, y: 460, width: PADDLE_WIDTH, height: PADDLE_HEIGHT };
    const ball = { x: 300, y: 430, dx: 0, dy: -BALL_SPEED, radius: 8 };
    const brickProto = { x: 0, y: 0, width: BRICK_WIDTH, height: BRICK_HEIGHT, fillStyle: "white", alive: true };
    const bricks = [];
    let score = 0;
    const audioCtx = new AudioContext();

    const playSfx = (freq, type, dur) => {
      if (audioCtx.state === 'suspended') return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
    };

    const sndBallBrick = () => playSfx(500, 'square', 0.1);  
    const sndBallPaddle = () => playSfx(300, 'triangle', 0.1);
    const sndBallWall = () => playSfx(200, 'sine', 0.1);
    const sndUnassigned1 = playSfx(150, 'sawtooth', 0.2);
    const sndUnassigned2 = () => playSfx(100, 'sawtooth', 0.5);
    

    // Initialize Bricks - part II
    for (let c = 0; c < BRICK_COLS; c++) {
      for (let r = 0; r < BRICK_ROWS; r++) {
        let x = (c * (BRICK_WIDTH + BRICK_PADDING)) + BRICK_OFFSET_LEFT;
        let y = (r * (BRICK_HEIGHT + BRICK_PADDING)) + BRICK_OFFSET_TOP;
        let fillStyle = `hsl(${r * 40}, 70%, 50%)`; // Rainbow rows
        let newBrick = Object.assign({}, brickProto, { x, y, fillStyle });
        bricks.push(newBrick);
      }
    }

  // part II
  const collisionDetection = () => {
    for (let b of bricks){
      if (b.alive) {
        // Check if ball is inside brick boundaries
        if (ball.x > b.x && ball.x < b.x + b.width && 
            ball.y > b.y && ball.y < b.y + b.height) {
            ball.dy = -ball.dy; // Bounce vertically
            b.alive = false;       // Destroy brick
            score += 10;
            sndBallBrick();
        }
      }
    }
  };

  const drawScore = () => {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FFF";
    ctx.fillText(`Score: ${score}`, 8, 20);
  };

  // part II
  const drawBricks = () => {
    for (let brick of bricks) {
      if (brick.alive) {
        ctx.fillStyle = brick.fillStyle;
        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
      }
    }
  };

  const draw = () => {
    // Draw Background
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawBricks(); // part II
    drawScore(); // part II

    // Draw Paddle
    ctx.fillStyle = PADDLE_COLOR;
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

    // Draw Ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = BALL_COLOR;
    ctx.fill();
    ctx.closePath();
  };

  const update = () => {
    // Move ball
    ball.x += ball.dx;
    ball.y += ball.dy;

    // Wall Collisions (Left/Right)
    if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx *= -1;
        sndBallWall();
    }

    // Wall Collisions (Top)
    if (ball.y - ball.radius < 0) {
        ball.dy *= -1;
        sndBallWall();
    }

    // Paddle Collision Logic
  if (ball.y + ball.radius > paddle.y && 
      ball.x > paddle.x && 
      ball.x < paddle.x + paddle.width) {
      
      // 1. Calculate the hit point (-1 to 1)
      let collidePoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
      
      // 2. Map to an angle (max 75 degrees)
      let angle = collidePoint * (Math.PI / 3); // PI/3 is 60 degrees

      // 3. Update velocity based on angle
      ball.dx = BALL_SPEED * Math.sin(angle);
      ball.dy = -BALL_SPEED * Math.cos(angle);
      
      // Push ball out of paddle to prevent sticking
      ball.y = paddle.y - ball.radius;
      sndBallPaddle();
    }

    collisionDetection();

    // Reset logic
    if (ball.y > canvas.height) {
        document.location.reload(); // Lame game over reset
    }
  }

  const loop = () => {
    update();
    draw();
    setTimeout(loop, 1000/60);
  };

  // init
  // Track mouse movement
  // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
  // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX
  //console.log(canvas.getBoundingClientRect().left);
  document.onmousemove = (e) => {
      const rect = canvas.getBoundingClientRect();
      //console.log(e.clientX); // x in document coordinates
      paddle.x = e.clientX - rect.left - paddle.width / 2;
  };

   //window.onclick = loop;
  // part II
  window.onclick = () => {if (audioCtx.state === 'suspended') audioCtx.resume()};
  
  loop();

	</script>
</head>
<body>
	<canvas width="640" height="480">
		Get a real browser!
	</canvas>
</body>
</html>
```


---
---


| <-- Previous Unit | Home | Next Unit -->
| --- | --- | --- 
| [**Week 4B Notes**](04B.md)  |  [**IGME-330 Schedule**](../schedule.md) | [**Week 5B Notes**](05B.md)
